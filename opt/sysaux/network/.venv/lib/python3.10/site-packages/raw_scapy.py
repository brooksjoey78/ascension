#!/usr/bin/env python3
# Raw socket implementation - No external dependencies
import socket
import struct
import binascii
from datetime import datetime

class RawSocket:
    def __init__(self, interface=None):
        self.interface = interface
        self.sock = socket.socket(socket.AF_PACKET, socket.SOCK_RAW, socket.ntohs(0x0003))
        if interface:
            self.sock.bind((interface, 0))
    
    def recv(self):
        return self.sock.recvfrom(65535)
    
    def send(self, packet):
        return self.sock.send(packet)
    
    def close(self):
        self.sock.close()

def parse_ethernet(data):
    dest_mac = binascii.hexlify(data[0:6]).decode('utf-8')
    src_mac = binascii.hexlify(data[6:12]).decode('utf-8')
    proto = struct.unpack('!H', data[12:14])[0]
    return dest_mac, src_mac, proto, data[14:]

def parse_ip(packet):
    version_ihl = packet[0]
    ihl = version_ihl & 0xF
    iph_length = ihl * 4
    src_ip = socket.inet_ntoa(packet[12:16])
    dst_ip = socket.inet_ntoa(packet[16:20])
    protocol = packet[9]
    return src_ip, dst_ip, protocol, packet[iph_length:]

def parse_udp(packet):
    src_port = struct.unpack('!H', packet[0:2])[0]
    dst_port = struct.unpack('!H', packet[2:4])[0]
    return src_port, dst_port, packet[8:]

def parse_dns(packet):
    try:
        transaction_id = struct.unpack('!H', packet[0:2])[0]
        flags = struct.unpack('!H', packet[2:4])[0]
        questions = struct.unpack('!H', packet[4:6])[0]
        
        offset = 12
        for _ in range(questions):
            qname_parts = []
            while packet[offset] != 0:
                length = packet[offset]
                qname_parts.append(packet[offset+1:offset+1+length].decode('utf-8', errors='ignore'))
                offset += length + 1
            offset += 1  # Skip null byte
            qtype = struct.unpack('!H', packet[offset:offset+2])[0]
            offset += 4  # QTYPE + QCLASS
            
            if qtype == 1:  # A record
                return '.'.join(qname_parts)
    except:
        pass
    return None

def arp_parse(packet):
    if len(packet) < 28:
        return None
    hardware_type = struct.unpack('!H', packet[0:2])[0]
    protocol_type = struct.unpack('!H', packet[2:4])[0]
    operation = struct.unpack('!H', packet[6:8])[0]
    src_mac = binascii.hexlify(packet[8:14]).decode('utf-8')
    src_ip = socket.inet_ntoa(packet[14:18])
    dest_mac = binascii.hexlify(packet[18:24]).decode('utf-8')
    dest_ip = socket.inet_ntoa(packet[24:28])
    return {
        'operation': 'request' if operation == 1 else 'reply',
        'src_mac': ':'.join([src_mac[i:i+2] for i in range(0,12,2)]),
        'src_ip': src_ip,
        'dest_mac': ':'.join([dest_mac[i:i+2] for i in range(0,12,2)]),
        'dest_ip': dest_ip
    }
RAW_SCAPY